<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="B. Alglave">
<meta name="dcterms.date" content="2025-01-01">

<title>Stats</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="sp_st_stats_M2_files/libs/clipboard/clipboard.min.js"></script>
<script src="sp_st_stats_M2_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="sp_st_stats_M2_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="sp_st_stats_M2_files/libs/quarto-html/popper.min.js"></script>
<script src="sp_st_stats_M2_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="sp_st_stats_M2_files/libs/quarto-html/anchor.min.js"></script>
<link href="sp_st_stats_M2_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="sp_st_stats_M2_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="sp_st_stats_M2_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="sp_st_stats_M2_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="sp_st_stats_M2_files/libs/bootstrap/bootstrap-d000793a9fe620b1dd56b6a1de844388.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Stats</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>B. Alglave </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 1, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>All ecological processes have a spatial and a spatio-temporal dimension: </p>
<p> </p>
<hr>
<hr>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="sp_st_stats_M2_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:75.0%"></p>
</figure>
</div>
</div>
</div>
<section id="data-and-ecological-processes" class="level2">
<h2 class="anchored" data-anchor-id="data-and-ecological-processes">Data and ecological processes</h2>
<p>What are the characteristics of these data?</p>
<p>What are the characteristics of the ecological process we want to infer?</p>
<p>How to relate the data to the ecological process?</p>
</section>
<section id="hierarchical-models" class="level2">
<h2 class="anchored" data-anchor-id="hierarchical-models">Hierarchical models</h2>
<hr>
<p><span class="math display">\[\mathbf{Y} | \mathbf{S},\boldsymbol{\theta}_{obs} \sim \mathcal{L}(\mathbf{S},\boldsymbol{\theta}_{obs})\]</span></p>
<p><span class="math inline">\(\mathbf{Y}\)</span>: observations</p>
<p><span class="math inline">\(\mathbf{S}\)</span>: latent field</p>
<p><span class="math inline">\(\mathcal{L}\)</span>: probability distribution of <span class="math inline">\(\mathbf{Y}\)</span></p>
<p><span class="math inline">\(\boldsymbol{\theta}_{obs}\)</span>: observation parameters</p>
<p><span class="math display">\[\mathbf{S} | \boldsymbol{\theta}_{process} \sim \mathcal{F}(\boldsymbol{\theta}_{process})\]</span></p>
<p><span class="math inline">\(\mathcal{F}\)</span>: probability distribution of <span class="math inline">\(\mathbf{S}\)</span></p>
<p><span class="math inline">\(\boldsymbol{\theta}_{process}\)</span>: process parameters</p>
<p> </p>
<p> </p>
</section>
</section>
<section id="basis-of-spatio-temporal-statistical-modeling" class="level1">
<h1>Basis of spatio-temporal statistical modeling</h1>
<p>Linear models are basis of statistical models. </p>
<p>For instance, in the case of EVHOE data for Argentina sphyraena, let’s assume that species spatio-temporal distribution <span class="math inline">\(\mathbf{S}\)</span> vary in space (<span class="math inline">\(x\)</span>), time (<span class="math inline">\(t\)</span>) and depends on a quadratic effect of depth.</p>
<p><span class="math display">\[\log(Y_i)  \overset{i.i.d}{\sim} \mathcal{N}(S(x_i,t_i),\sigma^2)\]</span></p>
<p><span class="math display">\[S(x,t)=\mu + \beta_1 \cdot \text{Depth}(x) + \beta_2 \cdot (\text{Depth}(x)) ^ 2\]</span></p>
<p><span class="math display">\[\log(Y_i) = \mu + \beta_1 \cdot \text{Depth}(x_i) + \beta_2 \cdot (\text{Depth}(x_i)) + \epsilon_i\]</span></p>
<p><span class="math display">\[\epsilon_i \overset{i.i.d}{\sim} \mathcal{N}(0,\sigma^2)\]</span></p>
<hr>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="sp_st_stats_M2_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:75.0%"></p>
</figure>
</div>
</div>
</div>
<hr>
<p>However, the i.i.d hypothesis is rarely satisfied in a spatio-temporal context as there can be spatio-temporal correlation structures in the residuals. </p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="sp_st_stats_M2_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%"></p>
</figure>
</div>
</div>
</div>
<section id="accounting-for-spatial-and-spatio-temporal-dependencies" class="level2">
<h2 class="anchored" data-anchor-id="accounting-for-spatial-and-spatio-temporal-dependencies">Accounting for spatial and spatio-temporal dependencies</h2>
<p> Introduce a Gaussian field (<span class="math inline">\(\mathcal{GF}\)</span>) <span class="math inline">\(\boldsymbol{\delta}\)</span> in the hierarchical framework that captures spatial / spatio-temporal correlation</p>
<p><span class="math display">\[\log(Y_i)  \overset{i.i.d}{\sim} \mathcal{N}(S(x_i,t_i),\sigma^2)\]</span></p>
<p><span class="math display">\[S(x,t)=\mu + \beta_1 \cdot \text{Depth}(x) + \beta_2 \cdot \text{Depth}(x) ^ 2 + \delta(x,t)\]</span></p>
<p><span class="math display">\[\boldsymbol{\delta} \sim \mathcal{GF}(0, \mathcal{C}(x, y ; t, r))\]</span></p>
<p>with <span class="math inline">\(\mathcal{C}(x, y ; t, r)\)</span> the spatio-temporal covariance function that controls the structure of <span class="math inline">\(\boldsymbol{\delta}\)</span></p>
</section>
<section id="defining-a-gaussian-field" class="level2">
<h2 class="anchored" data-anchor-id="defining-a-gaussian-field">Defining a Gaussian Field</h2>
<p>Simulation of a spatio-temporal Gaussian random field</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="sp_st_stats_M2_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Probability density function of a multivariate Normal distribution:</p>
<p><span class="math display">\[
f_{MN}(\delta_1,...,\delta_n)=(2 \pi)^{-n / 2}|\boldsymbol{\Sigma}|^{-1 / 2} \exp \left(-\frac{1}{2}\boldsymbol{\delta}^T \boldsymbol{\Sigma}^{-1}\boldsymbol{\delta}\right)
\]</span></p>
<hr>
<hr>
<hr>
<p>For a vector of <span class="math inline">\(p\)</span> random variables <span class="math inline">\(\mathbf{X}=(X_1,...,X_p)\)</span>:</p>
<p><span class="math display">\[
\operatorname{Var}(\mathbf{X})=\left(\begin{array}{cccc}
\operatorname{Var}\left(X_1\right) &amp; \operatorname{Cov}\left(X_1, X_2\right) &amp; \cdots &amp; \operatorname{Cov}\left(X_1, X_p\right) \\
\operatorname{Cov}\left(X_2, X_1\right) &amp; \ddots &amp; \cdots &amp; \vdots \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\operatorname{Cov}\left(X_p, X_1\right) &amp; \cdots &amp; \cdots &amp; \operatorname{Var}\left(X_p\right)
\end{array}\right)
\]</span></p>
<p>The correlation matrix is the normalized version of the covariance matrix.</p>
<p><span class="math inline">\(\operatorname{Var}(\mathbf{X})^{-1}\)</span> is the precision matrix.</p>
<hr>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="sp_st_stats_M2_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></p>
</figure>
</div>
</div>
</div>
<!-- --- -->
<!-- \begin{center} -->
<!-- \textbf{Correlation matrix of the simulated latent field (first time step) computed relatively to the y-coordinates} \vspace{\baselineskip} -->
<!-- \end{center} -->
<!-- \begin{center} -->
<!-- \ding{224} But this is not yet a variance-covariance matrix similar as the one used to model spatial or spatio-temporal correlation -->
<!-- \end{center} -->
</section>
<section id="spatial-variance-covariance" class="level2">
<h2 class="anchored" data-anchor-id="spatial-variance-covariance">Spatial variance-covariance</h2>
<p>Let’s consider the random effect <span class="math inline">\(\delta(x,t)\)</span> at a given time step <span class="math inline">\(t\)</span> that we rewrite <span class="math inline">\(\delta(x)\)</span>.</p>
<p>The spatial variance-covariance matrix of <span class="math inline">\(\delta(x)\)</span> can be written:</p>
<p><span class="math display">\[
\operatorname{Var}(\boldsymbol{\delta}(.))=\left(\begin{array}{cccc}
\operatorname{Var}\left(\delta(x_1)\right) &amp; \operatorname{Cov}\left(\delta(x_1), \delta(x_2) \right) &amp; \cdots &amp; \operatorname{Cov}\left(\delta(x_1), \delta(x_n) \right) \\
\operatorname{Cov}\left(\delta(x_2), \delta(x_1) \right) &amp; \ddots &amp; \cdots &amp; \vdots \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\operatorname{Cov}\left(\delta(x_n), \delta(x_1)\right) &amp; \cdots &amp; \cdots &amp; \operatorname{Var}\left(\delta(x_n)\right)
\end{array}\right)
\]</span></p>
<p>The spatial dependencies between the values of <span class="math inline">\(\boldsymbol{\delta}(.)\)</span> is modeled through a variance-covariance function <span class="math inline">\(\mathcal{C}(x, y)\)</span> (spatial only here).</p>
<p>Some base properties are required to define a spatial covariance function.</p>
<hr>
<p></p>
<p>A function <span class="math inline">\(\{\mathcal{C}(x,y):x,y\in D\}\)</span> defined on <span class="math inline">\(D\)</span> is said to be , if for any complex numbers <span class="math inline">\(\{a_i:i=1,...,m\}\)</span>, any <span class="math inline">\(\{x_i:i=1,...,m\}\)</span> in <span class="math inline">\(D\)</span>, and any integer <span class="math inline">\(m\)</span>, we have</p>
<p><span class="math display">\[\sum^m_{i=1}\sum^m_{j=1}a_i \bar{a}_j \mathcal{C}(x_i,x_j) \geq 0\]</span></p>
<p>where <span class="math inline">\(\bar{a}\)</span> denotes the complex conjugate of <span class="math inline">\(a\)</span>.</p>
<p>To be <span class="math inline">\(valid\)</span>, a covariance function must be non-negative definite.</p>
<p>A function is when the inequality below is strictly positive whenever <span class="math inline">\((a_1,...,a_m)'\)</span> is a nonzero vector.</p>
<hr>
<p></p>
<p>There are 2 main kinds of stationarity: strong and second-order (or weak) stationarity.</p>
<ul>
<li><p><span class="math inline">\(\delta(x)\)</span> is strongly stationary when the two probability measures defining <span class="math inline">\(\delta(x)\)</span> and <span class="math inline">\(\delta(x+h)\)</span> are equivalent for all <span class="math inline">\(h \in \mathbb{R}^d\)</span>.</p></li>
<li><p><span class="math inline">\(\delta(x)\)</span> is second-order (or weakly) stationary when it has a constant expectation and a stationary covariance function.</p></li>
</ul>
<p></p>
<p>Spatial isotropy corresponds to <span class="math inline">\(Cov(\delta(x),\delta(y)) \equiv \mathcal{C}(\|x-y\|)\)</span></p>
<p></p>
<p><span class="math inline">\(\delta(x)\)</span> is intrinsic if for all <span class="math inline">\((x) \in \mathbb{R}^d\)</span>, <span class="math inline">\(h \in \mathbb{R}\)</span>, <span class="math inline">\(\delta(x+h)+\delta(x)\)</span> is second-ordered stationary (constant expectation and stationary covariance).</p>
<hr>
</section>
<section id="spatial-application" class="level2">
<h2 class="anchored" data-anchor-id="spatial-application">Spatial application</h2>
<section id="data" class="level3">
<h3 class="anchored" data-anchor-id="data">Data</h3>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="sp_st_stats_M2_files/figure-html/Map%20the%20data-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="creating-the-mesh" class="level3">
<h3 class="anchored" data-anchor-id="creating-the-mesh">Creating the mesh</h3>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="sp_st_stats_M2_files/figure-html/Create%20mesh-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="building-the-spde-model" class="level3">
<h3 class="anchored" data-anchor-id="building-the-spde-model">Building the SPDE model</h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>myspde<span class="ot">=</span><span class="fu">inla.spde2.pcmatern</span>(<span class="at">mesh=</span>mesh,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>                           <span class="at">alpha=</span><span class="dv">2</span>,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>                           <span class="at">prior.range=</span><span class="fu">c</span>(.<span class="dv">01</span>,.<span class="dv">1</span>),</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>                           <span class="at">prior.sigma=</span><span class="fu">c</span>(<span class="dv">25</span>,<span class="fl">0.5</span>))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Observation matrix to make the connection </span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># between mesh nodes and observation sites:</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>A<span class="ot">=</span><span class="fu">inla.spde.make.A</span>(mesh,<span class="at">loc=</span>xy_OBS)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Vector of indices for the nodes of the mesh</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>idx.spatial<span class="ot">=</span><span class="fu">inla.spde.make.index</span>(<span class="st">"spatial"</span>,</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">n.spde=</span>mesh<span class="sc">$</span>n)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="building-the-regression-part" class="level3">
<h3 class="anchored" data-anchor-id="building-the-regression-part">Building the regression part</h3>
<p>First, we create covariate dataframe: we add the intercept term 1, since in <code>R-INLA</code> it’s more comfortable to include the intercept explicitly.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>covar.df<span class="ot">=</span><span class="fu">data.frame</span>(<span class="at">intercept=</span><span class="dv">1</span>,</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>                    <span class="at">x=</span>xy_OBS[,<span class="dv">1</span>],</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>                    <span class="at">y=</span>xy_OBS[,<span class="dv">2</span>])</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the stack with all the data and indices:</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>mystack<span class="ot">=</span><span class="fu">inla.stack</span>(<span class="at">data=</span><span class="fu">list</span>(<span class="at">pm10=</span>OBS_daily2014<span class="sc">$</span>PM10),</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>                   <span class="at">A=</span><span class="fu">list</span>(A,<span class="dv">1</span>),</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                   <span class="at">effects=</span><span class="fu">list</span>(idx.spatial,covar.df))</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># We write the formula for the model: </span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>myformula<span class="ot">=</span>pm10<span class="sc">~</span><span class="fu">f</span>(spatial,<span class="at">model=</span>myspde)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note: since we handle the intercept explicitly, we have to include “-1”). Recall that we have given the name “spatial” to the index of the spatial effect.</p>
</section>
<section id="fitting-the-model-with-r-inla" class="level3">
<h3 class="anchored" data-anchor-id="fitting-the-model-with-r-inla">Fitting the model with R-INLA</h3>
<p>The following <code>inla</code> run should take approximatively 1 minute.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>fit<span class="ot">=</span><span class="fu">inla</span>(myformula,</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>         <span class="at">data=</span><span class="fu">inla.stack.data</span>(mystack),</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">family=</span><span class="st">"gaussian"</span>, </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>         <span class="at">control.predictor=</span><span class="fu">list</span>(<span class="at">A=</span><span class="fu">inla.stack.A</span>(mystack),</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>                                <span class="at">compute=</span><span class="cn">FALSE</span>),</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>         <span class="at">control.inla=</span><span class="fu">list</span>(<span class="at">int.strategy=</span><span class="st">"eb"</span>,</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>                           <span class="at">strategy=</span><span class="st">"gaussian"</span>),</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>         <span class="at">verbose=</span>F)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Time used:
    Pre = 0.551, Running = 3.45, Post = 0.506, Total = 4.51 
Fixed effects:
             mean    sd 0.025quant 0.5quant 0.975quant  mode kld
(Intercept) 8.994 0.164      8.673    8.994      9.315 8.994   0

Random effects:
  Name    Model
    spatial SPDE2 model

Model hyperparameters:
                                         mean    sd 0.025quant 0.5quant
Precision for the Gaussian observations 0.009 0.000      0.009    0.009
Range for spatial                       0.020 0.006      0.009    0.020
Stdev for spatial                       4.377 0.454      3.612    4.335
                                        0.975quant  mode
Precision for the Gaussian observations      0.009 0.009
Range for spatial                            0.034 0.019
Stdev for spatial                            5.395 4.207

Marginal log-Likelihood:  -283181.01 
 is computed 
Posterior summaries for the linear predictor and the fitted values are computed
(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')</code></pre>
</div>
</div>
</section>
<section id="predictions-with-r-inla" class="level3">
<h3 class="anchored" data-anchor-id="predictions-with-r-inla">Predictions with R-INLA</h3>
<p>To build predictions, the input data (<code>inla.stack</code>) must be slightly modified. NA values are added to the vector of observations and inla will predict latent field values at these locations.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Observation matrix to make the connection between mesh nodes and observation sites:</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>proj_grid<span class="ot">=</span><span class="fu">inla.mesh.projector</span>(mesh,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>                              <span class="at">xlim=</span><span class="fu">range</span>(bound<span class="sc">$</span>loc[,<span class="dv">1</span>]),</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>                              <span class="at">ylim=</span><span class="fu">range</span>(bound<span class="sc">$</span>loc[,<span class="dv">2</span>]),</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>                              <span class="at">dims=</span><span class="fu">c</span>(<span class="dv">100</span>,<span class="dv">100</span>))</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Grid on wich we calculate the predictions:</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>xygrid<span class="ot">=</span><span class="fu">as.matrix</span>(<span class="fu">expand.grid</span>(proj_grid<span class="sc">$</span>x,proj_grid<span class="sc">$</span>y))</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Put prediction coordinates and observation coordinates into A:</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>A<span class="ot">=</span><span class="fu">inla.spde.make.A</span>(mesh,</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>                   <span class="at">loc=</span><span class="fu">rbind</span>(xygrid,xy_OBS))</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="co"># We add the intercept term 1, since in RINLA it's more comfortable to include the intercept explicitly.</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>covar.df<span class="ot">=</span><span class="fu">data.frame</span>(<span class="at">intercept=</span><span class="dv">1</span>,</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>                    <span class="at">x=</span><span class="fu">c</span>(xygrid[,<span class="dv">1</span>],</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>                        xy_OBS[,<span class="dv">1</span>]),</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>                    <span class="at">y=</span><span class="fu">c</span>(xygrid[,<span class="dv">2</span>],</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>                        xy_OBS[,<span class="dv">2</span>]))</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the stack with all the data and indices: add NA data here</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>mystack<span class="ot">=</span><span class="fu">inla.stack</span>(<span class="at">data=</span><span class="fu">list</span>(<span class="at">pm10=</span><span class="fu">c</span>(<span class="fu">rep</span>(<span class="cn">NA</span>,<span class="fu">nrow</span>(xygrid)),</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>                                    OBS_daily2014<span class="sc">$</span>PM10)),</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>                   <span class="at">A=</span><span class="fu">list</span>(A,<span class="dv">1</span>),</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>                   <span class="at">effects=</span><span class="fu">list</span>(idx.spatial,covar.df),</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>                   <span class="at">tag=</span><span class="st">"mytag"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
<p>When fitting, we now set <code>compute=TRUE</code> (to calculate fitted and predicted values) and <code>link=1</code> (although only necessary when using non-identity link).</p>
<p>Running INLA can now take considerably longer since we calculate the posterior estimation <code>y.hat</code> for each observation point <span class="math inline">\(y\)</span> (<code>compute=TRUE</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>fit<span class="ot">=</span><span class="fu">inla</span>(myformula,</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>         <span class="at">data=</span><span class="fu">inla.stack.data</span>(mystack),</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">family=</span><span class="st">"gaussian"</span>,</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>         <span class="at">control.predictor=</span><span class="fu">list</span>(<span class="at">A=</span><span class="fu">inla.stack.A</span>(mystack),</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>                                <span class="at">compute=</span><span class="cn">TRUE</span>,</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>                                <span class="at">link=</span><span class="dv">1</span>),</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>         <span class="at">control.inla=</span><span class="fu">list</span>(<span class="at">int.strategy=</span><span class="st">"eb"</span>,</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>                           <span class="at">strategy=</span><span class="st">"gaussian"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="sp_st_stats_M2_files/figure-html/Looking%20at%20prediction%20mean%20values-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<hr>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="sp_st_stats_M2_files/figure-html/Looking%20at%20prediction%20standard%20deviation-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<hr>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="sp_st_stats_M2_files/figure-html/Looking%20at%20Residuals-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<hr>
<p>Another (more general) way to define spatial structure is to define the <span class="math inline">\(Var(Y(x) - Y(y)) = 2 \gamma(x,y)\)</span> (with <span class="math inline">\(\gamma()\)</span> the ) and its stationary version <span class="math inline">\(2\gamma(h) = 2 (\mathcal{C}(0) - \mathcal{C}(h));h\in\mathbb{R}\)</span>.</p>
<hr>
<hr>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="sp_st_stats_M2_files/figure-html/unnamed-chunk-11-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
</div>
</div>
<p>For some toy example, see the codes `r/code_variog.R``</p>
</section>
</section>
<section id="moving-to-spatio-temporal" class="level2">
<h2 class="anchored" data-anchor-id="moving-to-spatio-temporal">Moving to spatio-temporal</h2>
<p>The ideas are similar, but we add temporal correlations in the expression of the random effect <span class="math inline">\(\boldsymbol{\delta}\)</span>.</p>
<p>For instance, let’s introduce the model:</p>
<p><span class="math display">\[\delta(x,t)=\varphi \cdot \delta(x,t-1) + \omega(x,t) \text{ for } t = 2,...,T\]</span></p>
<ul>
<li><p><span class="math inline">\(\varphi \in ]-1;1[\)</span> is the autoregressive temporal term</p></li>
<li><p><span class="math inline">\(\omega(x,t)\)</span> is a purely spatial GRF</p></li>
<li><p><span class="math inline">\(\omega(x,1)\)</span> derives from the stationary distribution <span class="math inline">\(\mathcal{N}(0,\sigma^2 / (1 - \varphi ^ 2))\)</span></p></li>
</ul>
<p><span class="math display">\[
\mathcal{C}\left(\omega\left(x, t\right), \omega\left(y, r\right)\right)= \begin{cases}0 &amp; \text { if } t \neq r \\ \sigma_\omega^2 \cdot Cor(h) &amp; \text { if } t=r \end{cases} \quad \text{ for } x \ne y
\]</span></p>
<p>where <span class="math inline">\(h = ||x-y|| \in \mathbb{R}\)</span> and <span class="math inline">\(Cor(h)\)</span> is the Matérn correlation function.</p>
<p>The variance-covariance matrix can be written as:</p>
<p><span class="math display">\[
\mathcal{C}\left(\delta\left(x, t\right), \delta\left(y, r\right)\right)= \frac{\varphi^{|t-r|}}{1-\varphi^2} \sigma_\omega^2 Cor(h)
\]</span></p>
<p>with <span class="math inline">\(|t-r|\)</span> the time lag between time step <span class="math inline">\(t\)</span> and <span class="math inline">\(r\)</span>.</p>
<hr>
<p>Such kind of process is:</p>
<ul>
<li><p>stationary: <span class="math inline">\(\mathcal{C}(x,y;t,r) = \mathcal{C}(h,\tau)\)</span> with <span class="math inline">\(h=||x-y||\)</span> and <span class="math inline">\(\tau=|t-r|\)</span>.</p></li>
<li><p>separable: <span class="math inline">\(\mathcal{C}(h,\tau)=\mathcal{C}^{(x)}(h) \cdot \mathcal{C}^{(t)}(\tau)\)</span></p></li>
<li><p>fully symmetric: <span class="math inline">\(cov(\delta(x,t);\delta(y,r))=cov(\delta(y,t);\delta(x,r))\)</span></p></li>
</ul>
<p> But other non-separable covariance function exist and might be desirable to model complex interactions between spatial and temporal correlations.</p>
</section>
<section id="spatio-temporal-application" class="level2">
<h2 class="anchored" data-anchor-id="spatio-temporal-application">Spatio-temporal application</h2>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="sp_st_stats_M2_files/figure-html/unnamed-chunk-12-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></p>
</figure>
</div>
</div>
</div>
<hr>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="sp_st_stats_M2_files/figure-html/unnamed-chunk-14-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:90.0%"></p>
</figure>
</div>
</div>
</div>
<hr>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="sp_st_stats_M2_files/figure-html/unnamed-chunk-15-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:90.0%"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="inference-method" class="level1">
<h1>Inference method</h1>
<section id="kriging" class="level2">
<h2 class="anchored" data-anchor-id="kriging">Kriging</h2>
<p> predict <span class="math inline">\(Y_0 = Y(x_0)\)</span> from observations <span class="math inline">\(\mathbf{Y}=(Y_1,\dots,Y_n)\)</span> at locations <span class="math inline">\((x_1,\dots,x_n)\)</span></p>
<p> [ Y_0 = _{i=1}^n <em>i Y_i, </em>{i=1}^n _i = 1 ]</p>
<p> [ _{_i} E!]</p>
<p></p>
<p>Let <span class="math inline">\(a_0=1\)</span>, <span class="math inline">\(a_i=-\ell_i\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\sum_{i=0}^n a_i=0\)</span></p>
<p>[ E!^2 = - _{i,j} a_i a_j , (|x_i-x_j|) ]</p>
</section>
<section id="maximum-likelihood-approach" class="level2">
<h2 class="anchored" data-anchor-id="maximum-likelihood-approach">Maximum likelihood approach</h2>
<p>Maximum likelihood methods consist in looking for the parameter values that maximize the likelihood <span class="math display">\[P (\mathbf{Y} | \boldsymbol{\theta})\]</span></p>
<p>For hierarchical models, this suppose to make an integral over the random effect <span class="math inline">\(\boldsymbol{\delta}\)</span> (with <span class="math inline">\(q\)</span> the size of <span class="math inline">\(\boldsymbol{\delta}\)</span>).</p>
<p><span class="math display">\[P (\mathbf{Y} | \boldsymbol{\theta}) = \int_{\mathbb{R}^{q}} P (\mathbf{Y}, \boldsymbol{\delta} | \boldsymbol{\theta}) d\delta\]</span></p>
<p>To bypass the computational burden:</p>
<ul>
<li><p>Laplace approximation</p></li>
<li><p>Pseudo-likelihood, etc.</p></li>
</ul>
</section>
<section id="bayesian-inference" class="level2">
<h2 class="anchored" data-anchor-id="bayesian-inference">Bayesian inference</h2>
<hr>
Random sampling in the joint posterior distribution <span class="math inline">\(\textcolor{BaptisteBlue}{P(\boldsymbol{\delta, \theta} | \mathbf{Y})}\)</span> (Metropolis-Hastings algorithm)
</section>
</section>
<section id="to-go-further" class="level1">
<h1>To go further</h1>
<hr>
<p>And by Christopher K. Wikle, Andrew Zammit-Mangion, and Noel Cressie. Published by Chapman &amp; Hall/CRC. </p>
<hr>
<ul>
<li><p>Some old school geostatistics: or </p>
<ul>
<li><p>Indices of spatial distributions</p></li>
<li><p>Structural analysis and variography</p></li>
<li><p>Dispersion and estimation variances</p></li>
<li><p>Kriging</p></li>
<li><p>Multivariate geostatistics</p></li>
<li><p>Geostatistical simulations</p></li>
</ul></li>
</ul>
<ul>
<li><p>Some more recent approaches: </p>
<ul>
<li><p>Spatio-temporal exploratory analysis</p></li>
<li><p>Descriptive modelling</p></li>
<li><p>Dynamic modelling</p></li>
<li><p>Model evaluation</p></li>
</ul></li>
</ul>
<hr>
<ul>
<li><strong>Data integration for heterogeneous spatial data</strong></li>
</ul>
<p>Alglave, B., Rivot, E., Etienne, M. P., Woillez, M., Thorson, J. T., &amp; Vermard, Y. (2022). Combining scientific survey and commercial catch data to map fish distribution. ICES Journal of Marine Science, 79(4), 1133-1149.</p>
<ul>
<li><strong>Spatio-temporal modelling of species distribution</strong></li>
</ul>
<p>Alglave, B., Vermard, Y., Rivot, E., Etienne, M. P., &amp; Woillez, M. (2023). Identifying mature fish aggregation areas during spawning season by combining catch declarations and scientific survey data. Canadian Journal of Fisheries and Aquatic Sciences, 80(5), 808-824.</p>
<ul>
<li><strong>Empirical Orthogonal Funcations or PCA for spatio-temporal data</strong></li>
</ul>
<p>Alglave, B., Olmos, M., Casemajor, J., Etienne, M. P., Rivot, E., Woillez, M., &amp; Vermard, Y. (2024). Investigating fish reproduction phenology and essential habitats by identifying the main spatio-temporal patterns of fish distribution. ICES Journal of Marine Science, 81(8), 1563-1574.</p>
<ul>
<li><strong>Integrated modelling of spatio-temporal dynamics</strong></li>
</ul>
<p>Olmos, M., Cao, J., Thorson, J. T., Punt, A. E., Monnahan, C. C., Alglave, B., &amp; Szuwalski, C. (2023). A step towards the integration of spatial dynamics in population dynamics models: eastern Bering Sea snow crab as a case study. Ecological Modelling, 485, 110484.</p>
<ul>
<li><strong>Joint species distribution model and abundance indices</strong></li>
</ul>
<p>Thorson, J. T., &amp; Barnett, L. A. (2017). Comparing estimates of abundance trends and distribution shifts using single-and multispecies models of fishes and biogenic habitat. ICES Journal of Marine Science, 74(5), 1311-1321.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>